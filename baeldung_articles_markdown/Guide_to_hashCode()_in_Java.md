# Guide to hashCode() in Java

## **1\. Overview**

Hashing is a fundamental concept of computer science.

In Java, efficient hashing algorithms stand behind some of the most popular collections, such as the _[HashMap](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/HashMap.html)_ (check out this in-depth [article](/java-hashmap)) and the _[HashSet](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/HashSet.html)_.

In this tutorial, we’ll focus on how _hashCode()_ works, how it plays into collections and how to implement it correctly.

## **2\. Using _hashCode()_ in Data Structures**

The simplest operations on collections can be inefficient in certain situations.

To illustrate, this triggers a linear search, which is highly ineffective for huge lists:
    
    
    List<String> words = Arrays.asList("Welcome", "to", "Baeldung");
    if (words.contains("Baeldung")) {
        System.out.println("Baeldung is in the list");
    }

Java provides a number of data structures for dealing with this issue specifically. For example, several _Map_ interface implementations are [hash tables](/cs/hash-tables).

When using a hash table, **these collections calculate the hash value for a given key using the _hashCode()_ method.** Then they use this value internally to store the data so that access operations are much more efficient.

## **3\. Understanding How _hashCode()_ Works**

Simply put, _hashCode()_ returns an integer value, generated by a hashing algorithm.

Objects that are equal (according to their _equals()_) must return the same hash code. **Different objects do not need to return different hash codes.**

The general contract of _hashCode()_ states:

  * Whenever it is invoked on the same object more than once during an execution of a Java application, _hashCode()_ must consistently return the same value, provided no information used in equals comparisons on the object is modified. This value doesn’t need to stay consistent from one execution of an application to another execution of the same application.


  * If two objects are equal according to the _equals(Object)_ method, calling the _hashCode()_ method on each of the two objects must produce the same value.


  * If two objects are unequal according to the [_equals(java.lang.Object)_](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Objects.html#equals\(java.lang.Object,java.lang.Object\)) method, calling the _hashCode_ method on each of the two objects doesn’t need to produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables.



> “As much as is reasonably practical, the _hashCode()_ method defined by class _Object_ does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the JavaTM programming language.)”

## **4\. A Naive _hashCode()_ Implementation**

A naive _hashCode()_ implementation that fully adheres to the above contract is actually quite straightforward.

To demonstrate this, we’re going to define a sample _User_ class that overrides the method’s default implementation:
    
    
    public class User {
    
        private long id;
        private String name;
        private String email;
    
        // standard getters/setters/constructors
            
        @Override
        public int hashCode() {
            return 1;
        }
            
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null) return false;
            if (this.getClass() != o.getClass()) return false;
            User user = (User) o;
            return id == user.id 
              && (name.equals(user.name) 
              && email.equals(user.email));
        }
        
        // getters and setters here
    }

The _User_ class provides custom implementations for both _equals()_ and _hashCode()_ that fully adhere to the respective contracts. Even more, there’s nothing illegitimate with having _hashCode()_ returning any fixed value.

**However, this implementation degrades the functionality of hash tables to basically zero, as every object would be stored in the same, single bucket.**

In this context, a hash table lookup is performed linearly and does not give us any real advantage. We talk more about this in Section 7.

## **5\. Improving the _hashCode()_ Implementation**

Let’s improve the current _hashCode()_ implementation by including all fields of the _User_ class so that it can produce different results for unequal objects:
    
    
    @Override
    public int hashCode() {
        return (int) id * name.hashCode() * email.hashCode();
    }

This basic hashing algorithm is definitively much better than the previous one. This is because it computes the object’s hash code by just multiplying the hash codes of the _name_ and _email_ fields and the _id_.

In general terms, we can say that this is a reasonable _hashCode()_ implementation, as long as we keep the _equals()_ implementation consistent with it.

## **6\. Standard _hashCode()_ Implementations**

The better the hashing algorithm that we use to compute hash codes, the better the performance of hash tables.

Let’s have a look at a “standard” implementation that uses two prime numbers to add even more uniqueness to computed hash codes:
    
    
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 31 * hash + (int) id;
        hash = 31 * hash + (name == null ? 0 : name.hashCode());
        hash = 31 * hash + (email == null ? 0 : email.hashCode());
        return hash;
    }

While we need to understand the roles that _hashCode()_ and _equals()_ methods play, we don’t have to implement them from scratch every time. This is because most IDEs can generate custom _hashCode()_ and _equals()_ implementations. And since Java 7, we have an _Objects.hash()_ utility method for comfortable hashing:
    
    
    Objects.hash(name, email)

[IntelliJ IDEA](https://www.jetbrains.com/idea/) generates the following implementation:
    
    
    @Override
    public int hashCode() {
        int result = (int) (id ^ (id >>> 32));
        result = 31 * result + name.hashCode();
        result = 31 * result + email.hashCode();
        return result;
    }

And [Eclipse](https://www.eclipse.org/downloads/) produces this one:
    
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((email == null) ? 0 : email.hashCode());
        result = prime * result + (int) (id ^ (id >>> 32));
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    }

In addition to the above IDE-based _hashCode()_ implementations, it’s also possible to automatically generate an efficient implementation, for example using [Lombok](https://projectlombok.org/features/EqualsAndHashCode).

In this case, we need to add the lombok dependency to _pom.xml_ :
    
    
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version>
    </dependency>

It’s now enough to annotate the _User_ class with _@EqualsAndHashCode_ :
    
    
    @EqualsAndHashCode 
    public class User {
        // fields and methods here
    }

Similarly, if we want [Apache Commons Lang’s _HashCodeBuilder_ class](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html) to generate a _hashCode()_ implementation for us, we include the [commons-lang](https://mvnrepository.com/search?q=apache-commons-lang) Maven dependency in the pom file:
    
    
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <version>3.14.0</version>
    </dependency>

And _hashCode()_ can be implemented like this:
    
    
    public class User {
        public int hashCode() {
            return new HashCodeBuilder(17, 37).
            append(id).
            append(name).
            append(email).
            toHashCode();
        }
    }

In general, there’s no universal recipe when it comes to implementing _hashCode()_. We highly recommend reading [Joshua Bloch’s Effective Java](https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997). It provides a list of [thorough guidelines](https://es.slideshare.net/MukkamalaKamal/joshua-bloch-effect-java-chapter-3) for implementing efficient hashing algorithms.

Notice here that all those implementations utilize number 31 in some form. This is because 31 has a nice property. Its multiplication can be replaced by a bitwise shift, which is faster than the standard multiplication:
    
    
    31 * i == (i << 5) - i

## **7\. Handling Hash Collisions**

The intrinsic behavior of hash tables brings up a relevant aspect of these data structures: Even with an efficient hashing algorithm, two or more objects might have the same hash code even if they’re unequal. So, their hash codes would point to the same bucket even though they would have different hash table keys.

This situation is commonly known as a hash collision, and [various methods exist for handling it](https://courses.cs.washington.edu/courses/cse373/18au/files/slides/lecture13.pdf), with each one having their pros and cons. Java’s _HashMap_ uses [the separate chaining method](https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists) for handling collisions:

**“When two or more objects point to the same bucket, they’re simply stored in a linked list. In such a case, the hash table is an array of linked lists, and each object with the same hash is appended to the linked list at the bucket index in the array.**

**In the worst case, several buckets would have a linked list bound to it, and the retrieval of an object in the list would be performed linearly.”**

Hash collision methodologies show in a nutshell why it’s so important to implement _hashCode()_ efficiently _._

Java 8 brought an interesting [enhancement to _HashMap_ implementation](http://openjdk.java.net/jeps/180). If a bucket size goes beyond the certain threshold, a tree map replaces the linked list. This allows achieving _O(_ logn _)_ lookup instead of pessimistic _O(n)_.

## **8\. Creating a Trivial Application**

Now we’ll test the functionality of a standard _hashCode()_ implementation.

Let’s create a simple Java application that adds some _User_ objects to a _HashMap_ and uses [SLF4J](/slf4j-with-log4j2-logback) for logging a message to the console each time the method is called.

Here’s the sample application’s entry point:
    
    
    public class Application {
    
        public static void main(String[] args) {
            Map<User, User> users = new HashMap<>();
            User user1 = new User(1L, "John", "john@domain.com");
            User user2 = new User(2L, "Jennifer", "jennifer@domain.com");
            User user3 = new User(3L, "Mary", "mary@domain.com");
    
            users.put(user1, user1);
            users.put(user2, user2);
            users.put(user3, user3);
            if (users.containsKey(user1)) {
                System.out.print("User found in the collection");
            }
        }
    }
    

And this is the _hashCode()_ implementation:
    
    
    public class User {
    
        // ...
    
        public int hashCode() {
            int hash = 7;
            hash = 31 * hash + (int) id;
            hash = 31 * hash + (name == null ? 0 : name.hashCode());
            hash = 31 * hash + (email == null ? 0 : email.hashCode());
            logger.info("hashCode() called - Computed hash: " + hash);
            return hash;
        }
    }

Here, it’s important to note that each time an object is stored in the hash map and checked with the _containsKey()_ method, _hashCode()_ is invoked and the computed hash code is printed out to the console:
    
    
    [main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: 1255477819
    [main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: -282948472
    [main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: -1540702691
    [main] INFO com.baeldung.entities.User - hashCode() called - Computed hash: 1255477819
    User found in the collection

## **9\. Conclusion**

It’s clear that producing efficient _hashCode()_ implementations often requires a mixture of a few mathematical concepts (i.e. prime and arbitrary numbers), logical and basic mathematical operations.

Regardless, we can implement _hashCode()_ effectively without resorting to these techniques at all. We just need to make sure the hashing algorithm produces different hash codes for unequal objects and that it’s consistent with the implementation of _equals()_.
